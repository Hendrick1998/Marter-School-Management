{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * @function importAll\n * @param {any} r - Require Context.\n * @returns {string} - File paths.\n */\n\n\nvar importAll = function importAll(r) {\n  return r.keys().map(r);\n};\n/**\n * @function importAllImages\n * @param {string} directory - The complete directory/folder path.\n * @param {regex} extensions - file extension filter.\n * @returns {string}\n */\n\n\nvar importAllImages = function importAllImages(directory) {\n  var extensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\\.(jpg|jpeg|png|svg)$/;\n  return importAll(require.context(directory, false, extensions));\n};\n/**\n * @function hasProperty\n * @param {string} property - The property to check for in the given object.\n * @param {object} object - The object in which to check for above given property.\n * @returns {any}\n */\n\n\nvar hasProperty = function hasProperty(property, object) {\n  try {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object) && object.hasOwnProperty(property);\n  } catch (e) {\n    console.warn(e.message, e);\n    return false;\n  }\n};\n/**\n * @function isObject\n * @param {object} object - Object to check if is an object.\n * @returns {boolean}\n */\n\n\nvar isObject = function isObject(object) {\n  try {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !Array.isArray(object);\n  } catch (e) {\n    console.warn(e.message, e);\n    return false;\n  }\n};\n\nvar Particle = function Particle(canvas, options) {\n  classCallCheck(this, Particle);\n\n  _initialiseProps.call(this);\n\n  var shape = options.shape,\n      color = options.color,\n      image = options.image,\n      size = options.size,\n      precision = options.precision,\n      x = options.x,\n      y = options.y,\n      debugOptions = options.debugOptions;\n  this.canvas = canvas;\n  this.ctx = canvas.getContext('2d');\n  this.shape = shape || 'circle';\n  this.color = color || '#F20000';\n  this.precision = precision || 2;\n  this.size = this.parseSize(size) || this.parseSize(+Math.random().toFixed(this.precision));\n  this.x = x || +Math.random().toFixed(this.precision);\n  this.y = y || +Math.random().toFixed(this.precision);\n  this.imageOptions = image || undefined;\n  this.image = new Image();\n  this.debug = debugOptions || {\n    enabled: false\n  }; // Errors\n\n  if (image !== undefined && !hasProperty('src', image)) {\n    throw new Error(\"Image object must have 'src' property.\");\n  }\n\n  if (!(hasProperty('width', this.size) && hasProperty('height', this.size)) && !hasProperty('radius', this.size)) {\n    throw new Error(\"Size object must have either 'width' AND 'height' OR 'radius' property.\");\n  }\n\n  if (this.debug.enabled) {\n    if (hasProperty('attachAllParticles', this.debug) && this.debug.attachAllParticles) {\n      window.Particles = window.Particles || [];\n      window.Particles.push(this);\n    }\n\n    window.Particle = this;\n  }\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.parseSize = function (size) {\n    var trueSize = size;\n\n    if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {\n      trueSize = _this.shape === 'circle' ? {\n        radius: size\n      } : {\n        width: size,\n        height: size\n      };\n    }\n\n    return trueSize;\n  };\n\n  this.draw = function () {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.x;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.y;\n    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.size;\n    var posX = _this.x = x;\n    var posY = _this.y = y;\n    var rSize = _this.size = size;\n\n    if (_this.imageOptions) {\n      _this.image.src = _this.imageOptions.src;\n\n      _this.ctx.drawImage(_this.image, _this.x, _this.y, _this.getSize('x'), _this.getSize('y'));\n    } else {\n      switch (_this.shape) {\n        case 'rectangle':\n        case 'rect':\n        case 'square':\n          var width = rSize.width,\n              height = rSize.height;\n\n          if (_this.shape === 'square') {\n            height = width;\n          }\n\n          _this.drawRectangle(posX, posY, width, height);\n\n          break;\n\n        case 'circle':\n        default:\n          var radius = rSize.radius;\n\n          _this.drawCircle(posX, posY, radius);\n\n          break;\n      }\n    }\n  };\n\n  this.drawCircle = function (x, y, radius) {\n    _this.ctx.beginPath();\n\n    _this.ctx.arc(x, y, radius, 0, Math.PI * 2);\n\n    _this.ctx.fillStyle = _this.color;\n\n    _this.ctx.fill();\n  };\n\n  this.drawRectangle = function (x, y, width, height) {\n    _this.ctx.fillStyle = _this.color;\n\n    _this.ctx.fillRect(x, y, width, height);\n  };\n\n  this.drawImage = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    console.log(args);\n\n    _this.ctx.drawImage.apply(_this.ctx, args);\n  };\n\n  this.getSize = function (axis) {\n    if (axis === 'x') {\n      return _this.size.width || _this.size.radius;\n    } else if (axis === 'y') {\n      return _this.size.height || _this.size.radius;\n    }\n  };\n};\n\nvar Particles =\n/**\n * @param canvas The html canvas element\n *\n * Example Particle Options:\n * @param options = {\n *   maxParticles: 0,\n *   colors: ['red', 'green', '#ff1000'],\n *   shapes: ['square', 'circle', 'rectangle', { type: 'image', src: '/path/to/image' }],\n *   size: 0.00,\n *   minSize: 0.00,\n *   maxSize: 0.00,\n *   velocity: 0.00,\n *   minSpeed: 0.00,\n *   maxSpeed: 0.00,\n *   alpha: 0.7\n * }\n *\n */\nfunction Particles(canvas, options) {\n  classCallCheck(this, Particles);\n\n  _initialiseProps$1.call(this);\n\n  var maxParticles = options.maxParticles,\n      backgroundColor = options.backgroundColor,\n      colors = options.colors,\n      shapes = options.shapes,\n      size = options.size,\n      minSize = options.minSize,\n      maxSize = options.maxSize,\n      minSpeed = options.minSpeed,\n      maxSpeed = options.maxSpeed,\n      alpha = options.alpha,\n      frameRate = options.frameRate,\n      duration = options.duration,\n      precision = options.precision,\n      debugOptions = options.debugOptions;\n  this.particles = [];\n  this.canvas = canvas;\n  this.ctx = canvas.getContext('2d');\n  this.precision = precision || 2;\n  this.canvas.style.backgroundColor = backgroundColor || '#f1f1f1';\n  this.maxParticles = maxParticles === null || maxParticles === undefined ? 50 : maxParticles;\n  this.colors = Array.isArray(colors) ? colors : [colors] || ['red', 'green', 'yellow'];\n  this.shapes = Array.isArray(shapes) ? shapes : [shapes] || ['circle', 'square', 'rectangle'];\n  this.size = size;\n  this.maxSize = +parseFloat(maxSize).toFixed(this.precision) || 20;\n  this.minSize = +parseFloat(minSize).toFixed(this.precision) || 10;\n  this.maxSpeed = +parseFloat(maxSpeed).toFixed(this.precision) || 0.09;\n  this.minSpeed = +parseFloat(minSpeed).toFixed(this.precision) || 0.05;\n  this.alpha = alpha || 0.5;\n  this.frameRate = frameRate || 0;\n  this.frameInterval = 1000 / this.frameRate;\n  this.duration = duration || 0;\n  this.debugOptions = debugOptions || {\n    showFrameRate: false\n  };\n  this.debug = {\n    frames: 0,\n    start: null,\n    frameRate: null\n  };\n  this.particleOptions = options;\n  this.paused = false;\n  this.createParticles();\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this = this;\n\n  this.createParticles = function () {\n    var _particles = [].concat(toConsumableArray(Array(_this.maxParticles)));\n\n    if (_this.maxParticles === 0 && _typeof(_this.shapes[0]) === 'object') {\n      _particles = _this.shapes;\n    }\n    /**\n     * @param {string|null|object} item - Shape object or string or null.\n     */\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _particles.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref = _step.value;\n\n        var _ref2 = slicedToArray(_ref, 2);\n\n        var i = _ref2[0];\n        var item = _ref2[1];\n        var particleOptions = Object.assign(_this.particleOptions, _this.buildParticleOptions(item));\n        var particle = new Particle(_this.canvas, particleOptions);\n\n        _this.attachParticleAnimationConfig(particle, item);\n\n        _this.positionCorrection(particle, i);\n\n        _this.particles = !Array.isArray(_this.particles) ? [] : _this.particles;\n\n        _this.particles.push(particle);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  };\n\n  this.buildParticleOptions = function () {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var particleOptions = {};\n\n    if (item !== null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n      particleOptions = Object.assign({}, item);\n\n      if (hasProperty('type', item) && item.type !== 'image') {\n        particleOptions.shape = item.type;\n      } else if (hasProperty('type', item) && item.type === 'image') {\n        particleOptions.shape = 'square';\n\n        if (hasProperty('src', item)) {\n          particleOptions.image = {\n            src: item.src\n          };\n        } else {\n          throw new Error('Shape of type `image` must have property `src`.');\n        }\n      } else {\n        particleOptions.shape = typeof item === 'string' ? item : _this.getRandomShape();\n      }\n    }\n\n    particleOptions.shape = particleOptions.shape || _this.shape || _this.getRandomShape();\n    particleOptions.size = particleOptions.size || _this.size || _this.genRandomSize(particleOptions.shape);\n\n    if (_typeof(particleOptions.size) !== 'object') {\n      particleOptions.size = _this.parseSize(particleOptions.size, particleOptions);\n    }\n\n    particleOptions.color = particleOptions.color || _this.getRandomColor();\n    particleOptions.x = particleOptions.x || _this.getRandomCoordinate('x', undefined, undefined, undefined, particleOptions);\n    particleOptions.y = particleOptions.y || _this.getRandomCoordinate('y', undefined, undefined, undefined, particleOptions);\n    return particleOptions;\n  };\n\n  this.attachParticleAnimationConfig = function (particle, item) {\n    if (hasProperty('animate', particle)) {\n      return particle;\n    }\n\n    particle.animate = {};\n    particle.animate.bounds = {};\n\n    if (particle.shape === 'circle') {\n      particle.animate.bounds.minX = particle.getSize('x');\n      particle.animate.bounds.minY = particle.getSize('y');\n    } else {\n      particle.animate.bounds.minX = particle.animate.bounds.minY = 0;\n    }\n\n    particle.animate.bounds.maxX = _this.canvas.width - particle.getSize('x');\n    particle.animate.bounds.maxY = _this.canvas.height - particle.getSize('y');\n    particle.animate.xSpace = particle.x + particle.animate.bounds.minX;\n    particle.animate.ySpace = particle.y + particle.animate.bounds.minY;\n    particle.animate.xSpace = _this.getDistance(particle, 'x');\n    particle.animate.ySpace = _this.getDistance(particle, 'y');\n\n    if (hasProperty('from', item)) {\n      particle.animate.to = {\n        x: particle.x,\n        y: particle.y,\n        size: particle.size,\n        duration: item.to.duration\n      };\n      particle.x = item.from.x;\n      particle.y = item.from.y;\n      particle.size = hasProperty('size', item.from) ? item.from.size : particle.size;\n    }\n\n    if (hasProperty('to', item)) {\n      particle.animate.to = item.to;\n    }\n\n    if (hasProperty('to', particle.animate)) {\n      var duration = hasProperty('duration', particle.animate.to) ? particle.animate.to.duration : _this.duration;\n      particle.animate.speed.x = (particle.animate.to.x - particle.x) / duration;\n      particle.animate.speed.y = (particle.animate.to.y - particle.y) / duration;\n      particle.animate.direction = {\n        x: particle.animate.to.x - particle.x > 0 ? -1 : 1,\n        y: particle.animate.to.y - particle.y > 0 ? -1 : 1\n      };\n    } else {\n      var direction = [1, -1];\n      particle.animate.speed = {};\n      particle.animate.speed.x = particle.animate.speed.y = _this.getRandomFloat(_this.minSpeed, _this.maxSpeed);\n      particle.animate.direction = {\n        x: direction[_this.getRandomInt(0, 1)],\n        y: direction[_this.getRandomInt(0, 1)]\n      };\n    }\n  };\n\n  this.getDistance = function (particle, axis) {\n    return particle[axis] + particle.getSize(axis);\n  };\n\n  this.positionCorrection = function (particle, i) {\n    var padding = 5;\n\n    var _particles = _this.particles.splice(i);\n\n    var _newParticles = _particles.map(function (_particle) {\n      if (_particle.x < particle.animate.xSpace || _particle.animate.xSpace > particle.x) {\n        var totalXSpace = particle.animate.xSpace + padding + _particle.animate.xSpace;\n\n        if (totalXSpace < _this.canvas.width) {\n          _particle.x = particle.animate.xSpace + padding;\n        } else {\n          _particle.x = particle.x - padding;\n        }\n      }\n\n      if (_particle.y < particle.animate.ySpace || _particle.animate.ySpace > particle.y) {\n        var totalYSpace = particle.animate.ySpace + padding + _particle.animate.ySpace;\n\n        if (totalYSpace < _this.canvas.height) {\n          _particle.y = particle.animate.ySpace + padding;\n        } else {\n          _particle.y = particle.y - padding;\n        }\n      }\n\n      return _particle;\n    });\n\n    _this.particles.concat(_newParticles);\n  };\n\n  this.animate = function () {\n    _this.interval = window.requestAnimationFrame(_this.animate);\n\n    _this.draw(); // Debug\n\n\n    if (_this.debugOptions.showFrameRate) {\n      _this.debug.start = _this.debug.start || performance.now();\n      var now = performance.now();\n      _this.debug.frames++;\n      var delta = now - _this.debug.start;\n\n      if (delta > 1000) {\n        _this.debug.frameRate = _this.debug.frames;\n        _this.debug.frames = 0;\n        _this.debug.start = performance.now();\n      }\n    }\n  };\n\n  this.draw = function () {\n    _this.ctx.clearRect(0, 0, _this.canvas.width, _this.canvas.height);\n\n    _this.ctx.globalAlpha = _this.alpha;\n\n    _this.particles.map(function (particle) {\n      if (hasProperty('to', particle.animate)) {\n        _this.incrementTo(particle);\n      } else {\n        _this.incrementor(particle);\n      }\n\n      particle.draw();\n\n      _this.ctx.restore();\n\n      return particle;\n    });\n  };\n\n  this.clear = function () {\n    window.cancelAnimationFrame(_this.interval);\n  };\n\n  this.incrementTo = function (particle) {// TODO: add logic\n  };\n\n  this.incrementor = function (particle) {\n    var directions = ['x', 'y', 'xy'];\n\n    var direction = directions[_this.getRandomInt(0, directions.length - 1)];\n\n    switch (direction) {\n      case 'x':\n        _this.safeIncrement(particle, 'x');\n\n        break;\n\n      case 'y':\n        _this.safeIncrement(particle, 'y');\n\n        break;\n\n      case 'xy':\n        _this.safeIncrement(particle, 'x');\n\n        _this.safeIncrement(particle, 'y');\n\n        break;\n    }\n  };\n\n  this.safeIncrement = function (particle, axis) {\n    var projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];\n\n    if (projection > particle.animate.bounds['max' + axis.toUpperCase()] || projection < particle.animate.bounds['min' + axis.toUpperCase()]) {\n      particle.animate.direction[axis] = -1 * particle.animate.direction[axis];\n      projection = particle[axis] + particle.animate.direction[axis] * particle.animate.speed[axis];\n    }\n\n    particle[axis] = projection;\n  };\n\n  this.getRandomShape = function () {\n    return _this.shapes[_this.getRandomInt(0, _this.shapes.length - 1)];\n  };\n\n  this.getRandomColor = function () {\n    return _this.colors[_this.getRandomInt(0, _this.colors.length - 1)];\n  };\n\n  this.getRandomCoordinate = function (axis, from, to, fixed, ctx) {\n    from = from || 0;\n    fixed = fixed || 2;\n\n    if (axis === 'x') {\n      // canvas width - size to keep particles within canvas boundary\n      to = to || _this.canvas.width - _this.getSize('x', ctx);\n    } else if (axis === 'y') {\n      // canvas width - size to keep particles within canvas boundary\n      to = to || _this.canvas.height - _this.getSize('y', ctx);\n    } else {\n      throw new Error('Illegal Axis!');\n    }\n\n    var x = _this.getRandomInt(from, to);\n\n    return x;\n  };\n\n  this.genRandomSize = function () {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'circle';\n    var size = void 0;\n\n    if (type === 'circle') {\n      size = {\n        radius: _this.getRandomInt(_this.minSize, _this.maxSize)\n      };\n    } else {\n      size = {\n        width: _this.getRandomInt(_this.minSize, _this.maxSize),\n        height: _this.getRandomInt(_this.minSize, _this.maxSize)\n      };\n\n      if (type === 'square') {\n        size.width = size.height;\n      }\n    }\n\n    return size;\n  };\n\n  this.getRandomFloat = function (min, max) {\n    return Math.random() * (max - min) + min;\n  };\n\n  this.getRandomInt = function (min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };\n\n  this.getSize = function (axis, particle) {\n    var object = (typeof particle === 'undefined' ? 'undefined' : _typeof(particle)) === 'object' ? particle : _this;\n    var dimension = axis === 'x' ? 'width' : 'height';\n\n    if (particle.shape === 'circle') {\n      dimension = 'radius';\n    }\n\n    return parseInt(object.size[dimension]);\n  };\n\n  this.parseSize = function (size, ctx) {\n    var trueSize = size;\n    var obj = ctx || _this;\n\n    if ((typeof size === 'undefined' ? 'undefined' : _typeof(size)) !== 'object') {\n      trueSize = obj.shape === 'circle' ? {\n        radius: size\n      } : {\n        width: size,\n        height: size\n      };\n    }\n\n    return trueSize;\n  };\n};\n\nvar aux = function aux(props) {\n  return props.children;\n};\n\nvar sizePropType = PropTypes.oneOf([{\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number\n}, {\n  radius: PropTypes.number.isRequired\n}, PropTypes.number]);\nvar shapePropType = PropTypes.shape({\n  type: PropTypes.oneOf(['image', 'rectangle', 'square', 'circle']).isRequired,\n  src: PropTypes.string,\n  size: sizePropType,\n  color: PropTypes.string,\n  to: PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number,\n    size: sizePropType,\n    duration: PropTypes.number,\n    speed: PropTypes.number\n  })\n});\n\nvar Canvas = function (_Component) {\n  inherits(Canvas, _Component);\n\n  function Canvas(props) {\n    classCallCheck(this, Canvas);\n\n    var _this = possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).call(this, props));\n\n    _initialiseProps$2.call(_this);\n\n    _this.handler = props.handler || Particles;\n    return _this;\n  }\n\n  createClass(Canvas, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      window.addEventListener('resize', function () {\n        if (_this2.canvas) {\n          _this2.canvasSizing(_this2.canvas);\n        }\n      });\n      this.canvasSizing(this.canvas);\n\n      if (this.particles !== null && _typeof(this.particles.debug) === 'object') {\n        this.debugInterval = setInterval(function () {\n          window.test = _this2.particles.debug;\n          var debug = Object.assign({}, _this2.particles.debug);\n\n          _this2.setState({\n            debug: debug\n          });\n        }, 1000);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _this3 = this;\n\n      window.removeEventListener('resize', function () {\n        _this3.canvasSizing(_this3.canvas);\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var debugElement = null;\n\n      if (this.state.debug !== null && _typeof(this.state.debug) === 'object' && this.state.debug.frameRate !== null) {\n        this.canvas.parentElement.style.position = 'relative';\n        debugElement = React.createElement('div', {\n          style: {\n            position: 'absolute',\n            top: 0,\n            right: 0,\n            fontSize: '14px',\n            padding: '10px',\n            color: 'white',\n            backgroundColor: 'rgba(0,0,0,0.7)'\n          }\n        }, this.state.debug.frameRate, ' ', React.createElement('i', null, 'fps'));\n      }\n\n      return React.createElement(aux, null, React.createElement('canvas', {\n        className: this.props.className,\n        style: this.props.style,\n        ref: function ref(canvas) {\n          _this4.canvas = canvas;\n        }\n      }), debugElement);\n    }\n  }]);\n  return Canvas;\n}(Component);\n\nCanvas.propTypes = {\n  options: PropTypes.shape({\n    maxParticles: PropTypes.number,\n    color: PropTypes.string,\n    colors: PropTypes.arrayOf(PropTypes.string),\n    shape: PropTypes.oneOfType([shapePropType, PropTypes.string]),\n    shapes: PropTypes.arrayOf(PropTypes.oneOfType([shapePropType, PropTypes.string])),\n    minSize: PropTypes.number,\n    maxSize: PropTypes.number,\n    size: PropTypes.number,\n    minSpeed: PropTypes.number,\n    maxSpeed: PropTypes.number,\n    alpha: PropTypes.number,\n    frameRate: PropTypes.number,\n    duration: PropTypes.number,\n    precision: PropTypes.number,\n    debugOptions: PropTypes.shape({\n      enabled: PropTypes.bool.isRequired,\n      attachAllParticles: PropTypes.bool,\n      attachSingleParticles: PropTypes.bool\n    })\n  }),\n  handler: function handler(props, propName, componentName) {\n    if (props.handler === null || props.handler === undefined) {\n      return null;\n    }\n\n    if (!props.handler.hasOwnProperty('animate') && typeof props.handler.animate !== 'function') {\n      return new Error(propName + ' must have an \\'animate\\' method in ' + componentName + '.');\n    }\n\n    if (!props.handler.hasOwnProperty('draw') && typeof props.handler.draw !== 'function') {\n      return new Error(propName + ' must have an \\'draw\\' method in ' + componentName + '.');\n    }\n\n    return null;\n  },\n  className: PropTypes.string,\n  style: PropTypes.object\n};\n\nvar _initialiseProps$2 = function _initialiseProps() {\n  var _this5 = this;\n\n  this.state = {\n    debug: null\n  };\n  this.handler = null;\n  this.debugInterval = null;\n\n  this.canvasSizing = function (canvas) {\n    window.can = canvas;\n    var wWidth = canvas.parentElement.clientWidth;\n    var wHeight = canvas.parentElement.clientHeight;\n    var scale = window.devicePixelRatio;\n    canvas.style.width = wWidth + 'px';\n    canvas.style.height = wHeight + 'px';\n    canvas.width = scale * wWidth;\n    canvas.height = scale * wHeight;\n\n    if (_this5.particles !== null && _typeof(_this5.particles) === 'object') {\n      _this5.particles.clear();\n\n      delete _this5.particles;\n    }\n\n    _this5.animate();\n  };\n\n  this.animate = function () {\n    var options = _this5.props.options;\n    var Handler = _this5.handler;\n    _this5.particles = new Handler(_this5.canvas, options);\n\n    _this5.particles.animate();\n  };\n};\n\nexport { Canvas, Particle, Particles, importAllImages, importAll, hasProperty, isObject };","map":null,"metadata":{},"sourceType":"module"}